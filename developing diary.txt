代码平台：RM开发板
FreeRTOS: V9.00
HAL库版本：1.13.0
作者：Satori

2019/2/13
建立了App和Bsp两个文件夹，分别放RTOS的task和bsp层的东西，目前打算先把遥控器数据的解码做掉，然后把can的发送做掉，最后实现一下遥控器控电机
主要工作看RemoteMsgTask.c和bsp_uart.c两个文件

2019/2/14
发现一个坑的要死的地方......
CUBEMX生成的功能引脚和板子上实际用的引脚不同的有好几个，就非常搞
遥控接收完成，但是是裸机的，实际上本来DJI的代码也没有用这个，但是有一个比较有意思的，专门有个任务用来执行模式切换，我觉得我们也可以尝试一下这个

2019/2/15
用信号量弄了一下模式切换
void RemoteMsg_Receive_ModeSw_TaskStart(void * argument)
{
    osEvent Event;
    while(1)
    {
        Event = osSignalWait(RC_MODE_SIGNAL | KM_MODE_SIGNAL | ST_MODE_SIGNAL , osWaitForever);

        //然后就是分一下模式咯
        if(Event.status == osEventSignal)
        {
            if(Event.value.signals & RC_MODE_SIGNAL)
            {
                HAL_GPIO_WritePin(LED_GREEN_GPIO_Port,LED_GREEN_Pin,RESET);
                HAL_GPIO_WritePin(LED_RED_GPIO_Port,LED_RED_Pin,SET);
            }
            if(Event.value.signals & KM_MODE_SIGNAL)
            {
                HAL_GPIO_WritePin(LED_RED_GPIO_Port,LED_RED_Pin,RESET);
                HAL_GPIO_WritePin(LED_GREEN_GPIO_Port,LED_GREEN_Pin,SET);
            }
            if(Event.value.signals & ST_MODE_SIGNAL)
            {
                HAL_GPIO_WritePin(LED_RED_GPIO_Port,LED_RED_Pin,RESET);
                HAL_GPIO_WritePin(LED_GREEN_GPIO_Port,LED_GREEN_Pin,RESET);
            }
        }
    }
}
就是这样的一个弱智玩意，感觉还是先设计一下整体的程序再去弄比较好，不然到时候写个乱七八糟的工程出来就太蠢了

大概理了一下程序，后面在这个基础上去再加更改吧
目前控制模式这样分：
typedef enum
{
chassis_follow_gimbal_remote_control，
chassis_follow_gimbal_keymouse_control，
chassis_free_keymouse_control，
chassis_sway，
chassis_stop，
}chassis_mode;

typedef enum
{
gimbal_remote_control，
gimbal_keymouse_control，
gimbal_auto，
gimbal_stop，
}gimbal_mode; 

typedef enum
{
shoot_auto，
shoot_remote_control，
shoot_keymouse_control，
shoot_stop，
}shoot_mode；

其中，如果是遥控器控制模式，则是
chassis_mode = CHASSIS_FOLLOW_GIMBAL_REMOTE_CONTROL

gimbal_mode = GIMBAL_REMOTE_CONTROL

shoot_mode = SHOOT_REMOTE_CONTROL/SHOOT_STOP

如果是停止模式，则是
chassis_mode = CHASSIS_STOP

gimabl_mode = GIMBAL_STOP

shoot_mode = SHOOT_STOP

如果是键盘控制模式，则是
chassis_mode = CHASSIS_FOLLOW_GIMBAL_KEYMOUSE_CONTROL/CHASSIS_FREE_KEYMOUSE_CONTROL/CHASSIS_SWAY/CHASSIS_STOP

gimbal_mode = GIMBAL_KEYMOUSE_CONTROL/GIMBAL_AUTO/GIMBAL_STOP

shoot_mode = SHOOT_KEYMOUSE_CONTROL/SHOOT_STOP

2019/2/16
代码的整体框架基本上搭建完毕，程序整体流程图也画了一部分，下面就是各个任务的具体实现上了，明天应该能够把底盘的task给完成掉
回头估计要建一个bsp_can来做can通信的相关参数
static void chassis_twist_handler(void)
{
  twist_count++;
  
  if (twist_side > 0)
  {
    if (gim.sensor.yaw_relative_angle >= 2*twist_angle)
    {
      twist_count = 0;
      twist_sign  = -1;
    }
    
    if(gim.sensor.yaw_relative_angle <= 0)
    {
      twist_count = 0;
      twist_sign  = 1;
    }
    
  }
  else
  {
    if (gim.sensor.yaw_relative_angle >= 0)
    {
      twist_count = 0;
      twist_sign  = -1;
    }
    
    if(gim.sensor.yaw_relative_angle <= -2*twist_angle)
    {
      twist_count = 0;
      twist_sign  = 1;
    }
    
  }
  chassis.position_ref = -twist_sign*twist_angle*cos(2*PI/twist_period*twist_count) + twist_side*twist_angle;
  
  chassis.vw = -pid_calc(&pid_chassis_angle, gim.sensor.yaw_relative_angle, chassis.position_ref);
  
}
ICRA的车的chassis_twist_handler
然后刚才跑了一下程序发现及其快乐的事情，软件定时器没开启成功，最后出来的结果是osError，非常的愤怒不知道到底是个什么鬼
然后看了一下是因为在FreeRTOSConfig.h下面的配置就不对，这就是一个非常有趣的坑了，我敲了这么久代码甚至都没有想到先去把FreeRTOSConfig.h先给修改一下，绝了
