代码平台：RM开发板
FreeRTOS: V9.00
HAL库版本：1.13.0
作者：Satori

2019/2/13
建立了App和Bsp两个文件夹，分别放RTOS的task和bsp层的东西，目前打算先把遥控器数据的解码做掉，然后把can的发送做掉，最后实现一下遥控器控电机
主要工作看RemoteMsgTask.c和bsp_uart.c两个文件

2019/2/14
发现一个坑的要死的地方......
CUBEMX生成的功能引脚和板子上实际用的引脚不同的有好几个，就非常搞
遥控接收完成，但是是裸机的，实际上本来DJI的代码也没有用这个，但是有一个比较有意思的，专门有个任务用来执行模式切换，我觉得我们也可以尝试一下这个

2019/2/15
用信号量弄了一下模式切换
void RemoteMsg_Receive_ModeSw_TaskStart(void * argument)
{
    osEvent Event;
    while(1)
    {
        Event = osSignalWait(RC_MODE_SIGNAL | KM_MODE_SIGNAL | ST_MODE_SIGNAL , osWaitForever);

        //然后就是分一下模式咯
        if(Event.status == osEventSignal)
        {
            if(Event.value.signals & RC_MODE_SIGNAL)
            {
                HAL_GPIO_WritePin(LED_GREEN_GPIO_Port,LED_GREEN_Pin,RESET);
                HAL_GPIO_WritePin(LED_RED_GPIO_Port,LED_RED_Pin,SET);
            }
            if(Event.value.signals & KM_MODE_SIGNAL)
            {
                HAL_GPIO_WritePin(LED_RED_GPIO_Port,LED_RED_Pin,RESET);
                HAL_GPIO_WritePin(LED_GREEN_GPIO_Port,LED_GREEN_Pin,SET);
            }
            if(Event.value.signals & ST_MODE_SIGNAL)
            {
                HAL_GPIO_WritePin(LED_RED_GPIO_Port,LED_RED_Pin,RESET);
                HAL_GPIO_WritePin(LED_GREEN_GPIO_Port,LED_GREEN_Pin,RESET);
            }
        }
    }
}
就是这样的一个弱智玩意，感觉还是先设计一下整体的程序再去弄比较好，不然到时候写个乱七八糟的工程出来就太蠢了

大概理了一下程序，后面在这个基础上去再加更改吧
目前控制模式这样分：
typedef enum
{
chassis_follow_gimbal_remote_control，
chassis_follow_gimbal_keymouse_control，
chassis_free_keymouse_control，
chassis_sway，
chassis_stop，
}chassis_mode;

typedef enum
{
gimbal_remote_control，
gimbal_keymouse_control，
gimbal_auto，
gimbal_stop，
}gimbal_mode; 

typedef enum
{
shoot_auto，
shoot_remote_control，
shoot_keymouse_control，
shoot_stop，
}shoot_mode；

其中，如果是遥控器控制模式，则是
chassis_mode = CHASSIS_FOLLOW_GIMBAL_REMOTE_CONTROL

gimbal_mode = GIMBAL_REMOTE_CONTROL

shoot_mode = SHOOT_REMOTE_CONTROL/SHOOT_STOP

如果是停止模式，则是
chassis_mode = CHASSIS_STOP

gimabl_mode = GIMBAL_STOP

shoot_mode = SHOOT_STOP

如果是键盘控制模式，则是
chassis_mode = CHASSIS_FOLLOW_GIMBAL_KEYMOUSE_CONTROL/CHASSIS_FREE_KEYMOUSE_CONTROL/CHASSIS_SWAY/CHASSIS_STOP

gimbal_mode = GIMBAL_KEYMOUSE_CONTROL/GIMBAL_AUTO/GIMBAL_STOP

shoot_mode = SHOOT_KEYMOUSE_CONTROL/SHOOT_STOP

2019/2/16
代码的整体框架基本上搭建完毕，程序整体流程图也画了一部分，下面就是各个任务的具体实现上了，明天应该能够把底盘的task给完成掉
回头估计要建一个bsp_can来做can通信的相关参数
static void chassis_twist_handler(void)
{
  twist_count++;
  
  if (twist_side > 0)
  {
    if (gim.sensor.yaw_relative_angle >= 2*twist_angle)
    {
      twist_count = 0;
      twist_sign  = -1;
    }
    
    if(gim.sensor.yaw_relative_angle <= 0)
    {
      twist_count = 0;
      twist_sign  = 1;
    }
    
  }
  else
  {
    if (gim.sensor.yaw_relative_angle >= 0)
    {
      twist_count = 0;
      twist_sign  = -1;
    }
    
    if(gim.sensor.yaw_relative_angle <= -2*twist_angle)
    {
      twist_count = 0;
      twist_sign  = 1;
    }
    
  }
  chassis.position_ref = -twist_sign*twist_angle*cos(2*PI/twist_period*twist_count) + twist_side*twist_angle;
  
  chassis.vw = -pid_calc(&pid_chassis_angle, gim.sensor.yaw_relative_angle, chassis.position_ref);
  
}
ICRA的车的chassis_twist_handler

2019/2/17
把软件定时器开了，里面软件定时中断回调云台的控制任务和底盘的控制任务
然后刚才跑了一下程序发现及其快乐的事情，软件定时器没开启成功，最后出来的结果是osError，非常的愤怒不知道到底是个什么鬼
然后看了一下是因为在FreeRTOSConfig.h下面的配置就不对，这就是一个非常有趣的坑了，我敲了这么久代码甚至都没有想到先去把FreeRTOSConfig.h先给修改一下，绝了
然后就能成功跑软件定时器了，记住软件定时器的默认优先级是belowNormalPriority,所以其他任务如果不是以阻塞态运行就都能随随便便的打断它
还有一个非常坑的东西，就是我突然发现一开始我创建工程的时候貌似是打算只写个demo还是啥的，所以一开始初始化的串口中断只有串口6一个，这就非常的坑了，因为实际用的工程怕是好几个串口中断都需要用上，此时一名不知死活的肥宅进入了自闭状态，更惨的是我定时器的外设就初始化了一个6号定时器，真jb精彩
现在一个隐藏的雷区就是ICRA的车子弄了一堆定时器，而我并不知道它开这么多定时器究竟想做一些什么，搞得我非常非常慌

2019/2/18
开学没几天了嘤嘤嘤，先把can的收发写掉再说，由于目前没有mpu等乱七八糟玩意的资料，所以我现在也不太想继续细化我的程序框架图了
基本上写完了bsp_can，上手测试了一下自己写的can，结果
你写尼玛呢？？？？？？
非常非常的崩，跑了几次之后就会报can_error，我也很懵逼很不爽，艹
准确的说是这样的一个状态
整个CAN发送会有三次发送处于成功的，确实进入了HAL_CAN_STATE_BUSY_TX里面去，但是三次之后就会完美进入error，这就让我很懵逼
另外貌似can的接收中断也没有进去

主要涉及到的问题是hcan1.Instance.TSR这一位，这是正常发送的情况：
0x1C000003

而我的情况：
0x1C000000
0x19000008
0x52000008
0x82000008

emmmm好的吧，那我就看看到底是哪边会使得这个值变化，最惨的是，我没找到

好吧我tm就是个傻逼，我按照ICRA的外设配置进行的初始化，但是一点鸟用都没有，然后我就按照A型板的进行了一下配置，然后稳了
  hcan1.Instance = CAN1;
  hcan1.Init.Prescaler = 3;
  hcan1.Init.Mode = CAN_MODE_NORMAL;
  hcan1.Init.SJW = CAN_SJW_1TQ;
  hcan1.Init.BS1 = CAN_BS1_9TQ;
  hcan1.Init.BS2 = CAN_BS2_4TQ;
  hcan1.Init.TTCM = DISABLE;
  hcan1.Init.ABOM = DISABLE;
  hcan1.Init.AWUM = DISABLE;
  hcan1.Init.NART = DISABLE;
  hcan1.Init.RFLM = DISABLE;
  hcan1.Init.TXFP = ENABLE;
贴一下'正确'的配置和'错误'的配置
  hcan1.Instance = CAN1;
  hcan1.Init.Prescaler = 5;
  hcan1.Init.Mode = CAN_MODE_NORMAL;
  hcan1.Init.SJW = CAN_SJW_1TQ;
  hcan1.Init.BS1 = CAN_BS1_3TQ;
  hcan1.Init.BS2 = CAN_BS2_5TQ;
  hcan1.Init.TTCM = DISABLE;
  hcan1.Init.ABOM = ENABLE;
  hcan1.Init.AWUM = DISABLE;
  hcan1.Init.NART = DISABLE;
  hcan1.Init.RFLM = DISABLE;
  hcan1.Init.TXFP = DISABLE;
既然遥控器的数据也读出来了，电机也能动了，那么接下来就只剩下一件事情了，那就是......今晚写一个能动的底盘出来，嘿嘿嘿

2019/2/19
然后我就咕了，没来的及写完（哦豁，完蛋.jpg）
今天上午把到底盘电机的解算给写掉了，还是靠自己写工程才真实的感受到FreeRTOS的强大之处
第一，可以节省硬件资源，比如软件定时器功能，产生的软件定时中断效果和硬件定时中断没有感受到区别
第二，基于任务与任务通知的更高的抽象思路，可以使编程的思路变得更加清晰，所有的任务都可以抽象成线程，只要处理线程之间的关系就可以，而在这之前基于轮询-中断的代码要写起来就比较容易思路混乱，因为都是在各种中断回调里面乱丢东西
第三，更加灵活。尤其是osSignalSet()和osSignalWait()这两个函数，可以说用起来非常的爽，可以当成一种万能的'外部中断'来用，某种程度上甚至可以说OS其实拓展了32的中断系统

总的来说，我目前对于os的使用其实也才刚刚是冰山一角，但也切实的感受到os的功能真的非常非常强大，用好了可以非常好的帮助完成庞大的工程

喜出新bug，接收的时候进不了中断回调函数，然后就闭不了环，非常的郁闷了可以说
而且最谜的是我的发送是完全正常的，按照CAN的通讯协议，每一帧都应该是有Ack的，这就非常非常非常奇怪
总之发送是完全没有任何问题的，但是接收就从始至终都是一切为0，这使我极度郁闷

搞定了，初始化的过滤器弄得有点问题，我虽然感觉自己弄得和能动的这版毫无区别，但是最后就是读不出来东西，绝了
提一下这版能用的
void Can_Device_Init(CAN_HandleTypeDef* hcan)
{
  CAN_FilterConfTypeDef canfilter;
  
  static CanTxMsgTypeDef  Tx1Message;
  static CanRxMsgTypeDef  Rx1Message;
  static CanTxMsgTypeDef  Tx2Message;
  static CanRxMsgTypeDef  Rx2Message;
  
  canfilter.FilterMode              = CAN_FILTERMODE_IDMASK;
  canfilter.FilterScale             = CAN_FILTERSCALE_32BIT;
  
  canfilter.FilterIdHigh            = 0x0000;
  canfilter.FilterIdLow             = 0x0000;
  canfilter.FilterMaskIdHigh        = 0x0000;
  canfilter.FilterMaskIdLow         = 0x0000;
  
  canfilter.FilterFIFOAssignment    = CAN_FilterFIFO0;
  canfilter.FilterActivation        = ENABLE;
  canfilter.BankNumber              = 14;
  
  if(hcan == &hcan1)
  {
    canfilter.FilterNumber = 0;
    hcan->pTxMsg = &Tx1Message;
    hcan->pRxMsg = &Rx1Message;
  }
  if(hcan == &hcan2)
  {
    canfilter.FilterNumber = 14;
    hcan->pTxMsg = &Tx2Message;
    hcan->pRxMsg = &Rx2Message;
  }
  
  HAL_CAN_ConfigFilter(hcan, &canfilter);
  
}

2019/2/20
昨天想直接初始化的时候赋值一波pid参数，后来发现不靠谱，因为有这样的一个机制：
#include <stdio.h>

typedef struct
{
    int a;
    int b;
} B;

typedef struct
{
    int c;
    B d;
} A;

int main()
{
    A C.d={1,2};
    printf("%d",C.c);
}

这样的结构体赋值是无法成功的

#include <stdio.h>

typedef struct
{
    int a;
    int b;
} B;

typedef struct
{
    int c;
    B d;
} A;

int main()
{
    A C = {1,{2,3}};
    printf("%d",C.d.a);
}

而这种嵌套就可以了

调了一波底盘，动的和真的一样，不过使用起来依然只能说是游戏体验不是很佳，毕竟pid参数调的比较烂，回头可能会再调调，说到头那么大的静差是从哪里来的就搞得我很懵逼

还有一个很讨厌的事情，RM开发板的can2接口是个tm4pin的，而c610电调出来的是2pin的，又要自己魔改一下线头了，nmd，wsm

